# Untitled

- **피드의 응답시간을 빠르게 하기 위한 방법, DB 저장 관점에서 설명**

    SNS의 개념을 타 버리기 직전까지 졸이다 보면 꾸덕꾸덕하게 남는 것은 결국 친구들의 이야기를 모아서 볼 수 있는 '모아 보기'(Facebook의 뉴스피드, 트위터와 LINE의 타임라인) 기능이다. 다시 말해, 기능적 관점에서 SNS와 기존 서비스의 차이를 설명한다면, 관계들의 연결 고리를 통해 내 친구들의 이야기를 모아 보여주는 기능이 그 차이의 본질이라고 할 수 있다.

    [NAVER D2](https://d2.naver.com/helloworld/551588)

    - 모아보기의 기본 구조 자체는 복잡하지 않다. 가장 익숙한 게시판 형태를 떠올릴 수 있다.

    게시판에서 특정 사용자(친구, Follower)가 작성한 글을 검색하여 or로 연결하여 검색하면 끝이다. (*작성자 OR 굴비 알고리즘*)
    - **follow한 친구의 수가 m, 전체 사용자 수가 n**이면 사용자 검색 연산의 시간복잡도는 O(m log(n))이 된다.
    - 전체 게시물의 수를 I라고 하면 **페이징 비용은 O(log(I))** 이다. I는 다시 사용자별 평균 보유 게시물 수를 k라고 하면 k*n이고, **O(log(kn))이라 할 수 있다.**
    - O(m log(n)):**O(log(kn)) ,** m : log(k)/log(n) +1 이 되고, m이 자리수가 더 많을것이다. Facebook 통계를 토대로 하면 **페이징 비용보다 모아보기가 260배** 더 비용이 많이 들고, 모든 사용자가 모아보기를 볼 때마다 이 비용이 발생한다.
    - 가장 먼저 생각할 수 있는 시간을 줄일 수 있는 방법은 **캐시를 이용**하는 것이다. DB로 가는 트래픽을 줄이면서 빠르게 반응할 수 있게 한다. ( 구현하기 꽤 힘들것) ⇒ `첫번 째 해결법은 캐시`  LAMP(Linux, Apache, MySQL, PHP) 기반에서 가장 흔하게 쓰이는 **memcached**를 이용하면 DB로 가는 트래픽을 크게 줄이고 빠르게 반응할 수 있다.
        - **memcached**
            - in-Memory : Disk에 Access할 필요가 없어 굉장히 빠른 응답속도를 가짐
            - 분산형 : 새로운 노드를 손쉽게 추가하여 확장 가능
            - Multi Thread : Core를 최대한 이용 가능
    - 데이터 양이 굉장히 많아지면? Facebook의 경우에 MySQL 샤드 4000대, memcached 샤드 9000대 이상을 구성하고 있다. 맞는 데이터를 찾기 위해 중간 서버가 또 많이 필요하고, 이런 복잡한 구성 때문에 비지니스 로직은 구성에 묶이게 된다.

        이러한 구조로 인해 각 친구의 데이터가 곳곳에 흩어지게 되고, 새로 사귄 친구의 데이터도 수많은 샤드 어딘가에 두게 된다. 이런 상태에서 *작성자 OR 굴비 알고리즘*은 어떻게 돌릴까?

    - 사용자의 데이터가 샤드의 어디에 사는지 찾을 방법이 필요하다. 
    하나하나 관리할 수도 있고, 해시를 이용할 수도 있다. 
    전자는 주소의 유연성이 있지만 저장소가 추가로 필요하고, 후자는 단순하지만 유연성이 떨어진다.

        이 **두가지의 장점을 혼합하는 Consistent Hashing 구조**를 자주 사용하곤 한다.
        데이터의 저장소 주소를 저장하는 대신 한정된 전체 주소를 여러 범위로 나누어 각 저장소에 대응시켜 사용하는 방식이다.

        - **Consistent Hashing**

            N개의 캐시머신이 구성돼 있다고 가정해보자. 이 경우 해쉬 함수는 hash(0) mod n으로 나타낼 수 있다. 

            잘 작동하지만 캐시가 추가되거나 삭제되서 n 이 변경될 경우 거의 모든 객체의 위치도 함께 변경, hash가 무용지물이 된다. 

            결국 처음부터 다시 캐시를 구축해야 하는데, 이미 캐시 요청이 빗발치고 있다면 시스템에 문제가 생길 수 있다. **Consistent 해시**를 이용해서 이러한 문제를 극복할 수 있다.

            - **Hash Ring**

                이해를 쉽게 하기 위해서, 어떤 hash의 결과가 0 부터 1 까지 float 형태로 나온다고 가정하겠습니다. hash(“host1”) = 0.25, 

                hash(“host2”) = 0.5, hash(“host3”) = 0.75 가 나온다고 가정하고, 특정 key에 대한 hash 결과는 그것보다 hash값이 크면서 가장 가까운 host에 저장이 된다고 하겠습니다. 즉 hash(“key1”) = 0.3 이면 key1이라는 key가 위치할 서버는 0.5 값을 가지는 host2가 되게 됩니다. 0.75 보다 크면 Ring 이므로 다시 첫번째 host1에 저장이 되게 됩니다.

                이제 우리는 hash 함수와 서버의 목록만 알면, 바로 특정 key를 어디에 저장할 것인지 결정할 수 있게 되었습니다. 그리고 Consistent Hashing은 위에서 말했듯이… 서버가 추가되거나 없어져도, 1/k 개의 key만 사라지는 특성이 있습니다. 이것은 또 어떻게 보장이 되는 것일까요?

                hash(“host4”) = 0.6 인 서버가 하나 추가되었다고 가정하겠습니다. 이 서버가 들어오면 순서는host1, host2, host4, host3 이 됩니다. 즉 host4 와 host3 사이의 값, 즉 hash 함수의 결과가 0.6 ~ 0.75 인 녀석들만 저장해야 할 서버가 바뀌지, 다른 녀석들은 원래의 위치에 그대로 저장되므로 찾을 수 있게 됩니다.

                다시 정리하자면, A, B, C 세 대의 서버가 hash Ring을 구성합니다.

                ![https://charsyam.files.wordpress.com/2011/11/4.png?w=295&h=300](https://charsyam.files.wordpress.com/2011/11/4.png?w=295&h=300)

                여기에 1이라는 key가 들어오면 hash(“1”) 해서 그 결과값을 보니 B가 규칙에 맞아서 B에 저장되게 됩니다.

                ![https://charsyam.files.wordpress.com/2011/11/5.png?w=295&h=300](https://charsyam.files.wordpress.com/2011/11/5.png?w=295&h=300)

                이제 두번 째 2가 들어올 경우 hash(“2”) 한 값이 C에 속해야 하므로 C에 저장되게 됩니다.

                ![https://charsyam.files.wordpress.com/2011/11/6.png?w=295&h=300](https://charsyam.files.wordpress.com/2011/11/6.png?w=295&h=300)

                마지막으로 key 3,4는 hash(“3”), hash(“4”) 의 값이 A 서버에 속하므로 A 에 들어가고 key 5는 C에 가까워서 C에 들어가게 됩니다.

                ![https://charsyam.files.wordpress.com/2011/11/7.png?w=295&h=300](https://charsyam.files.wordpress.com/2011/11/7.png?w=295&h=300)

                그런데 위의 예제나 그림을 보면, A, B, C의 공간이 서로 균일하지가 않습니다. 또, B가 죽는다고 가정하면 B의 부하는 전부 C로 넘어가게 됩니다. 뭔가 불공평한 일이 벌어지는 것이죠. 그래서 이것을 해결하기 위해서 가상의 친구들을 더 만들어냅니다.

                가상의 친구들을 한 서버당 2개씩 더 만든다고 하면 hash(‘A’), hash(‘A+1’), hash(‘A+2’) 로 Hash Ring 에 추가합니다. B는 hash(‘B’), hash(‘B+1’), hash(‘B+2’) 등으로 추가하면 됩니다. 즉 총 3개의 서버를 9개로 보이게 하는거죠. 아래와 같이 A+1은 실제로는 A지만, hash ring에서 가상적으로 다른 녀석으로 보이게 됩니다. hash ring 자체도 더 촘촘해지고, 어떤 서버가 한대 장애가 나더라도, 그 부하가, 적절하게 나머지 두 서버로 나눠지게 됩니다. 실제 서비스에서는 서버당 수십개의 가상 노드를 만들어서 처리하게 됩니다.(2~3개도 너무 적습니다.) 이것을 보통 vnode 라고 부르게 됩니다.

                ![https://charsyam.files.wordpress.com/2012/11/ch2.png?w=300&h=273](https://charsyam.files.wordpress.com/2012/11/ch2.png?w=300&h=273)

                핵심 결론은, 서버 이름으로 hash 값을 만들어서 정렬한 것을 하나의 Ring 처럼 생각해서 key를 hash 값에 따라 저장한다입니다.

                - **Server Alias**

                    **Hash Ring**이 우리가 의도한 것과 다르게 구성되는 경우가 언제가 될까요? 바로… **Hash Ring을 구성하는 서버의 이름이 바뀌게 되는 경우**입니다.

                    Consistent hashing을 많이 쓰는 libmemcached 의 경우 보통 **서버 주소**가 들어가게 됩니다. “1.1.1.1:11211”, “1.1.1.2:11211”, “1.1.1.3:11211” 그런데 이런 이름의 경우에 만약 **1.1.1.2 서버가 문제가 있어서 새 장비를 받아야 하는데 그 장비가 1.1.1.4 의 ip를 가진다면?** Hash Ring이 꼬여 버릴 수 있습니다. 이런 문제를 해결하려면 위의 **직접적인 이름 대신에 alias 한 다른 이름으로 Consistent Hashing 을 구성**해야 합니다. 즉 redis001, redis002, redis003, redis004 이런 이름으로 Hash Ring을 구성하고, 서버가 바뀌더라도 이 이름을 사용하고 **Consistent Hashing**의 결과로 가져올 값만 다르게 가져오면 되는 것이죠.

            - 
    - 피드는 굉장히 형태가 많다. 사진,비디오,좋아요,공유,댓글,링크 등등.. 게시판 구조라고 하면 하나의 게시물에 굉장히 많은 부가 필드가 필요하다. 수천개의 캐시와 DB 서버가 있으므로 최소한의 구조로 최대한의 표현력을 가지며 빠르게 읽을 수 있어야 한다.

    게시물의 **트랙백 기능** 을 생각해 보면, 게시글의 내부에서 트랙백처럼 댓글,유저,좋아요 등을 연결하여 사용하면 최소한의 구조로 최대한의 표현력을 가질 수 있게 된다. 이는 그래프 자료 구조를 통해 구현할 수 있다.

        ![Untitled%201e577c1bf40e4a89adfd0c45708f838e/Untitled.png](Untitled%201e577c1bf40e4a89adfd0c45708f838e/Untitled.png)

    - 여기서 가장 발전하는 부분이 캐시인데, 기존의 memcached를 look-ahead 캐시로 사용했다면 이제는 TAO( The Associations and Objects ) 라는 그래프 자료구조의 write-thru 캐시로 대체한 것이다.

        **TAO를 이용하여 기존의 프로그램 로직에서 캐시를 관리하고 DB도 관리한 것에서 TAO에만 쓰면 DB에 저장되는 구조로 바뀌었다.**